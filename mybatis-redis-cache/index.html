<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>SpringBoot——Mybatis配置Redis二级缓存 | 小丁的blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://maodou38.github.io/favicon.ico?v=1586614736143">
<link rel="stylesheet" href="https://maodou38.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一级缓存
MyBatis 会在表示会话的 SqlSession 对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询..." />
    <meta name="keywords" content="springboot,Java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://maodou38.github.io">
        <img src="https://maodou38.github.io/images/avatar.png?v=1586614736143" class="site-logo">
        <h1 class="site-title">小丁的blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://maodou38.github.io" class="site-nav">
            主页
          </a>
        
      
        
          <a href="https://maodou38.github.io/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://maodou38.github.io/archives" class="site-nav">
            归档
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      <div><span>在技术的道路上慢慢找寻自我的价值</span>
                                             <span class="rt">  ———小丁 
   </span></div>
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/maodou38">randing</a> | <a class="rss" href="https://maodou38.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">SpringBoot——Mybatis配置Redis二级缓存</h2>
            <div class="post-date">2020-03-27</div>
            
            <div class="post-content" v-pre>
              <h1 id="一级缓存">一级缓存</h1>
<p>MyBatis 会在表示会话的 SqlSession 对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。</p>
<p>一级缓存是 SqlSession 级别的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个（内存区域）数据结构（HashMap）用于存储缓存数据。不同的 sqlSession 之间的缓存数据区域（HashMap）是互相不影响的。其作用域是同一个 SqlSession，在同一个 sqlSession 中两次执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个 sqlSession 结束后该 sqlSession 中的一级缓存也就不存在了。Mybatis 默认开启一级缓存。</p>
<h1 id="二级缓存">二级缓存</h1>
<p>二级缓存是 mapper 级别的缓存，多个 SqlSession 去操作同一个 Mapper 的 sql 语句，多个 SqlSession 去操作数据库得到数据会存在二级缓存区域，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。其作用域是 mapper 的同一个 namespace，不同的 sqlSession 两次执行相同 namespace下的 sql 语句且向 sql 中传递参数也相同即最终执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis 默认没有开启二级缓存需要在 setting 全局参数中配置开启二级缓存。</p>
<h1 id="开启-mybatis-二级缓存">开启 MyBatis 二级缓存</h1>
<p>在 Spring Boot 配置文件中开启 MyBatis 二级缓存，配置代码如下：</p>
<pre><code>mybatis:
  configuration:
    cache-enabled: true
</code></pre>
<h1 id="实体类实现序列化接口并声明序列号">实体类实现序列化接口并声明序列号</h1>
<p>private static final long serialVersionUID = 8289770415244673535L;</p>
<h1 id="idea-提示生成序列号">IDEA 提示生成序列号</h1>
<p>默认情况下 Intellij IDEA 不会提示继承了 Serializable 接口的类生成 serialVersionUID 的警告。如果需要生成 serialVersionUID，需要手动配置。<br>
File -&gt; Settings -&gt; Inspections -&gt; Serialization issues -&gt; Serialization class without 'serialVersionUID'<br>
<img src="https://maodou38.github.io/post-images/1585299053580.png" alt="" loading="lazy"></p>
<h1 id="创建相关工具类">创建相关工具类</h1>
<h2 id="实现-spring-applicationcontextaware-接口用于手动注入-bean">实现 Spring ApplicationContextAware 接口，用于手动注入 Bean</h2>
<p>创建一个名为 ApplicationContextHolder 的工具类，代码如下：</p>
<pre><code>import org.apache.commons.lang3.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class ApplicationContextHolder implements ApplicationContextAware, DisposableBean {
    private static final Logger logger = LoggerFactory.getLogger(ApplicationContextHolder.class);

    private static ApplicationContext applicationContext;

    /**
     * 获取存储在静态变量中的 ApplicationContext
     *
     * @return
     */
    public static ApplicationContext getApplicationContext() {
        assertContextInjected();
        return applicationContext;
    }

    /**
     * 从静态变量 applicationContext 中获取 Bean，自动转型成所赋值对象的类型
     *
     * @param name
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T&gt; T getBean(String name) {
        assertContextInjected();
        return (T) applicationContext.getBean(name);
    }

    /**
     * 从静态变量 applicationContext 中获取 Bean，自动转型成所赋值对象的类型
     *
     * @param clazz
     * @param &lt;T&gt;
     * @return
     */
    public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) {
        assertContextInjected();
        return applicationContext.getBean(clazz);
    }

    /**
     * 实现 DisposableBean 接口，在 Context 关闭时清理静态变量
     *
     * @throws Exception
     */
    public void destroy() throws Exception {
        logger.debug(&quot;清除 SpringContext 中的 ApplicationContext: {}&quot;, applicationContext);
        applicationContext = null;
    }

    /**
     * 实现 ApplicationContextAware 接口，注入 Context 到静态变量中
     *
     * @param applicationContext
     * @throws BeansException
     */
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        ApplicationContextHolder.applicationContext = applicationContext;
    }

    /**
     * 断言 Context 已经注入
     */
    private static void assertContextInjected() {
        Validate.validState(applicationContext != null, &quot;applicationContext 属性未注入，请在 spring-context.xml 配置中定义 ApplicationContextHolder&quot;);
    }
}
</code></pre>
<h2 id="实现-mybatis-cache-接口用于自定义缓存为-redis">实现 MyBatis Cache 接口，用于自定义缓存为 Redis</h2>
<p>创建一个名为 RedisCache 的工具类，代码如下：</p>
<pre><code>import com.funtl.itoken.common.context.ApplicationContextHolder;
import org.apache.ibatis.cache.Cache;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Redis 缓存工具类
 * &lt;p&gt;Title: RedisCache&lt;/p&gt;
 * &lt;p&gt;Description: &lt;/p&gt;
 *
 * @author Lusifer
 * @version 1.0.0
 * @date 2018/8/13 6:03
 */
public class RedisCache implements Cache {
    private static final Logger logger = LoggerFactory.getLogger(RedisCache.class);

    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final String id; // cache instance id
    private RedisTemplate redisTemplate;

    private static final long EXPIRE_TIME_IN_MINUTES = 30; // redis过期时间

    public RedisCache(String id) {
        if (id == null) {
            throw new IllegalArgumentException(&quot;Cache instances require an ID&quot;);
        }
        this.id = id;
    }

    @Override
    public String getId() {
        return id;
    }

    /**
     * Put query result to redis
     *
     * @param key
     * @param value
     */
    @Override
    public void putObject(Object key, Object value) {
        try {
            RedisTemplate redisTemplate = getRedisTemplate();
            ValueOperations opsForValue = redisTemplate.opsForValue();
            opsForValue.set(key, value, EXPIRE_TIME_IN_MINUTES, TimeUnit.MINUTES);
            logger.debug(&quot;Put query result to redis&quot;);
        } catch (Throwable t) {
            logger.error(&quot;Redis put failed&quot;, t);
        }
    }

    /**
     * Get cached query result from redis
     *
     * @param key
     * @return
     */
    @Override
    public Object getObject(Object key) {
        try {
            RedisTemplate redisTemplate = getRedisTemplate();
            ValueOperations opsForValue = redisTemplate.opsForValue();
            logger.debug(&quot;Get cached query result from redis&quot;);
//            System.out.println(&quot;****&quot; + opsForValue.get(key).toString());
            return opsForValue.get(key);
        } catch (Throwable t) {
            logger.error(&quot;Redis get failed, fail over to db&quot;, t);
            return null;
        }
    }

    /**
     * Remove cached query result from redis
     *
     * @param key
     * @return
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public Object removeObject(Object key) {
        try {
            RedisTemplate redisTemplate = getRedisTemplate();
            redisTemplate.delete(key);
            logger.debug(&quot;Remove cached query result from redis&quot;);
        } catch (Throwable t) {
            logger.error(&quot;Redis remove failed&quot;, t);
        }
        return null;
    }

    /**
     * Clears this cache instance
     */
    @Override
    public void clear() {
        RedisTemplate redisTemplate = getRedisTemplate();
        redisTemplate.execute((RedisCallback) connection -&gt; {
            connection.flushDb();
            return null;
        });
        logger.debug(&quot;Clear all the cached query result from redis&quot;);
    }

    /**
     * This method is not used
     *
     * @return
     */
    @Override
    public int getSize() {
        return 0;
    }

    @Override
    public ReadWriteLock getReadWriteLock() {
        return readWriteLock;
    }

    private RedisTemplate getRedisTemplate() {
        if (redisTemplate == null) {
            redisTemplate = ApplicationContextHolder.getBean(&quot;redisTemplate&quot;);
        }
        return redisTemplate;
    }
}
</code></pre>
<h2 id="mapper-接口中增加注解">Mapper 接口中增加注解</h2>
<p>在 Mapper 接口中增加注解，声明需要使用二级缓存</p>
<pre><code>import com.funtl.itoken.common.domain.TbSysUser;
import com.funtl.itoken.common.utils.RedisCache;
import org.apache.ibatis.annotations.CacheNamespace;
import tk.mybatis.mapper.MyMapper;

@CacheNamespace(implementation = RedisCache.class)
public interface TbSysUserMapper extends MyMapper&lt;TbSysUser&gt; {
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://maodou38.github.io/bk1AeQmzB/" class="tag">
                    springboot
                  </a>
                
                  <a href="https://maodou38.github.io/rEjH4-Bi46/" class="tag">
                    Java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://maodou38.github.io/useful-urls/">
                  <h3 class="post-title">
                    各种资源地址整理
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '17ec64f773b1afaef948',
        clientSecret: '27224f5f2766e28963056872d67b6b477a06f19a',
        repo: 'comment',
        owner: 'maodou38',
        admin: ['maodou38'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
